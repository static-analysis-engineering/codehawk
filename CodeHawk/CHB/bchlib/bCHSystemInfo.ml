(* =============================================================================
   CodeHawk Binary Analyzer 
   Author: Henny Sipma
   ------------------------------------------------------------------------------
   The MIT License (MIT)
 
   Copyright (c) 2005-2020 Kestrel Technology LLC
   Copyright (c) 2020      Henny Sipma
   Copyright (c) 2021-2023 Aarno Labs LLC

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:
 
   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.
  
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
   ============================================================================= *)

(* -----------------------------------------------------------------------------
   Description
   -----------------------------------------------------------------------------
   system_info is a global source of information for disassembly and analysis.
   Its sources of information are:
   - user data, read in from chu/<appname>_system_u.xml, supplemented with
       data from chu/structs and chu/jumptables. This information is read
       only on the first iteration of the analysis, indicated by the absence
       of the analysis-generated ch/analysis/<appname>_system.xml
   - xfile header data
   - xfile symbols
   - data generated by the disassembly
   -------------------------------------------------------------------------- *)


(* chlib *)
open CHPretty

(* chutil *)
open CHLogger
open CHPrettyUtil
open CHXmlDocument
open CHXmlReader
open CHUtil

(* xprlib *)
open XprTypes
open XprXml

(* bchlib *)
open BCHBasicTypes
open BCHBCFiles
open BCHBCTypes
open BCHBCTypeXml
open BCHByteUtilities
open BCHCallbackTables
open BCHConstantDefinitions
open BCHCppClass
open BCHCStruct
open BCHCStructConstant
open BCHDataBlock
open BCHDataExportSpec
open BCHDemangler
open BCHDoubleword
open BCHFunctionData
open BCHInterfaceDictionary
open BCHJumpTable
open BCHLibTypes
open BCHMemoryReference
open BCHPreFileIO
open BCHSectionHeadersInfo
open BCHSpecializations
open BCHStreamWrapper
open BCHStrings
open BCHStructTables
open BCHSystemData
open BCHSystemSettings
open BCHTypeDefinitions
open BCHUtilities
open BCHVariable
open BCHXmlUtil

module H = Hashtbl
module TR = CHTraceResult


module DoublewordCollections = CHCollections.Make (
  struct
    type t = doubleword_int
    let compare d1 d2 = d1#compare d2
    let toPretty d = d#toPretty
  end)

module DataBlockCollections = CHCollections.Make (
  struct
    type t = data_block_int
    let compare b1 b2 = b1#compare b2
    let toPretty b = b#toPretty
  end)
 
let file_as_string = ref ""
let id = BCHInterfaceDictionary.interface_dictionary


let geta_fail
      (name: string) (node: xml_element_int) (tag: string): doubleword_int =
  let dw = string_to_doubleword (node#getAttribute tag) in
  if Result.is_ok dw then
    TR.tget_ok dw
  else
    fail_tvalue
      (trerror_record
         (LBLOCK [
              STR "geta:system_info#";
              STR name;
              STR " with tag:";
              STR tag;
              STR " and value:";
              STR (node#getAttribute tag)]))
      dw


class system_info_t:system_info_int  =
object (self)


  (* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
   *                                                           initialization *
   * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
  val mutable has_file = false
  val mutable filename = ""
  val mutable xfilesize = 0
  val mutable is_elf = false
  val mutable is_mips = false
  val mutable is_arm = false
  val mutable is_power = false
  val mutable preamble_cutoff = 12   (* minimum number of observed preambles, to
                                        use instruction as reason to add function
                                        entry point *)

  val mutable jumptables = []
  val mutable ifiles = []

  val data_blocks = new DataBlockCollections.set_t
  val jumptargets = H.create 13

  (* fa,ia of jmp* instr -> (base address,lb option, ub option) *)
  val jumptabletargets = H.create 13

  val indirect_jump_targets = H.create 13  (* fa,ia -> target list *)
    
  val nonreturning_calls = new DoublewordCollections.table_t
  val fixedtrueconditionals = new DoublewordCollections.set_t
  val excluded_jumptables = new DoublewordCollections.set_t
  val invalidated_jumptable_startaddresses = new DoublewordCollections.set_t
  val jumptable_splits = H.create 3
  val goto_returns = new DoublewordCollections.table_t
  val userdeclared_codesections = new DoublewordCollections.table_t
  val mutable readonly_ranges = []
  val initialized_memory = H.create 3
    
  val function_call_targets = H.create 13  (* (faddr, iaddr) -> call_target_t *)
  val variable_intros = H.create 13 (* iaddr#index -> name *)

  val esp_adjustments = H.create 3      (* indexed with faddr, iaddr *)
  val esp_adjustments_i = H.create 3    (* indexed with iaddr *)
  val cfnops = H.create 3               (* indexed with iaddr, cfg obfuscations *)
  val cfjmps = H.create 3      (* indexed with iaddr, cfg obfuscated jumps *)
  val thread_start_functions = H.create 13 
  val exported_item_names = H.create 3
  val class_membership = H.create 2
  val mutable constant_files = []

  (* functions loaded via LoadLibrary/GetProcAddress *)
  val lib_functions_loaded = H.create 3
  val successors = H.create 3
  val arm_thumb_switches = H.create 3

  (* constraints on function arguments/global variables.
     format:
        <arg-constraints>
          <fn a=hex-address>
            <c n=arg-name offset=offset lb=lb ub=ub v=v/>
            ...
          </fn>
          <fn>
          ....
          </fn>
        </arg-constraints>

     offset indicates field offset of argument deref

     table: fn -> arg -> (int option, int option, int option)
   *)
  val argument_constraints = H.create 3

  val mutable user_data_blocks = 0 
  val mutable user_call_targets = 0
  val mutable user_structs = 0 
  val mutable user_nonreturning = 0
  val mutable user_classes = 0
  val mutable encodings = []
  val mutable inlined_functions = []
  val mutable trampolines = []

  val data_export_specs = H.create 3

  method set_preamble_cutoff (n:int) = preamble_cutoff <- n

  method get_preamble_cutoff = preamble_cutoff

  method is_in_readonly_range (a:doubleword_int) =
    List.fold_left (fun r (s,e) -> r || (s#le a && a#lt e)) false readonly_ranges

  method get_successors (a:doubleword_int) =
    let hxa = a#to_hex_string in
    if H.mem successors hxa then
      let _ =
        chlog#add
          "provide successors"
          (LBLOCK [
               STR hxa; STR ": ";
               INT (List.length (H.find successors hxa))]) in
      H.find successors hxa
    else
      []

  method set_arm_thumb_switch (addr: doubleword_int) (arch: string) =
    begin
      chlog#add
        "arm-thumb switch" (LBLOCK [addr#toPretty; STR ": "; STR arch]);
      H.add arm_thumb_switches addr#index arch
    end

  method get_arm_thumb_switch (a: doubleword_int): string option =
    if H.mem arm_thumb_switches a#index then
      Some (H.find arm_thumb_switches a#index)
    else
      None

  method is_thumb (addr: doubleword_int) =
    if system_settings#has_thumb then
      let index = addr#index in
      let switches =
        List.sort
          (fun (k1, _) (k2, _) -> Stdlib.compare k1 k2)
          (H.fold (fun k v a -> (k, v) :: a) arm_thumb_switches []) in
      let result =
        List.fold_left (fun (prev, aarch) (adr, arch) ->
            match aarch with
            | Some _ -> (prev, aarch)
            | _ ->
               if adr > index then
                 (prev, Some prev)
               else
                 (arch, None)) ("A", None) switches in
      match result with
      | (_, Some "A") -> false
      | (_, Some "T") -> true
      | _ -> false
    else
      false

  method import_ida_function_entry_points =
    match load_ida_dbfe_file () with
    | Some node ->
       begin
         chlog#add "initialization" (STR "ida function entry points");
         List.iter (fun fnode ->
             let fa = TR.tget_ok (string_to_doubleword (fnode#getAttribute "a")) in
             if functions_data#is_function_entry_point fa then () else
               let fd = functions_data#add_function fa in
               fd#set_ida_provided) (node#getTaggedChildren "fe")
       end
    | _ -> ()

  method get_initialized_memory_strings =
    H.fold
      (fun k v a ->
        (TR.tget_ok (string_to_doubleword k), v) :: a) initialized_memory []
(*
  method import_ida_function_entry_points =
    match load_ida_dbfe_file () with
    | Some node ->
      begin
	chlog#add "initialization" (STR "read ida function entry points file") ;
	List.iter (fun fNode ->
	  let a =  string_to_doubleword (fNode#getAttribute "a") in
	  if function_entry_points#has a then () else
	    begin
	      function_entry_points#add a ;
	      chlog#add "ida function entry point" a#toPretty ;
	      ida_function_entry_points#add a
	    end) (node#getTaggedChildren "fe")
      end
    | _ -> 
      chlog#add "initialization" (STR "No ida function entry points file found")
 *)
  method get_ida_function_entry_points =
    functions_data#get_ida_provided_function_entry_points

  method set_thread_start_address (faddr:doubleword_int) (iaddr:ctxt_iaddress_t)
    (start_addr:doubleword_int) (args:bterm_t list) =
    let index = start_addr#index in
    let entry = if H.mem thread_start_functions index then
	H.find thread_start_functions index 
      else 
	let e = H.create 3 in 
	begin 
	  H.add thread_start_functions index e ; 
	  ignore (functions_data#add_function start_addr) ;
          chlog#add
            "set thread start address"
            (LBLOCK [
                 faddr#toPretty;
                 STR ", ";
                 STR iaddr;
                 STR ": ";
                 start_addr#toPretty]);
	  e 
	end in
    H.replace entry (faddr#index,iaddr) args

  method is_thread_start_address (addr:doubleword_int) =
    H.mem thread_start_functions addr#index

  method get_thread_start_arguments (addr:doubleword_int):bterm_t list list =
    if H.mem thread_start_functions addr#index then
      let entry = H.find thread_start_functions addr#index in
      let result = ref [] in
      let _ = H.iter (fun _ v -> result := v :: !result) entry in
      !result
    else
      raise
        (BCH_failure
           (LBLOCK [
                STR "Address ";
                addr#toPretty;
		STR " is not a known thread start address"]))

  method add_ifile (name: string) =
    ifiles <- name :: ifiles

  method ifiles = ifiles

  method add_lib_function_loaded (dll:string) (name:string) =
    let entry = if H.mem lib_functions_loaded dll then
	H.find lib_functions_loaded dll else [] in
    let entry = if List.mem name entry then entry else name :: entry in
    H.replace lib_functions_loaded dll entry

  method add_esp_adjustment (faddr:doubleword_int) (iaddr:doubleword_int)
    (adj:int) =
    H.add esp_adjustments (faddr#index, iaddr#index) adj

  method private add_esp_adjustment_i (iaddr:doubleword_int) (adj:int) =
    H.add esp_adjustments_i iaddr#index adj

  method add_inlined_function (faddr:doubleword_int) =
    let fd = functions_data#add_function faddr in
    begin
      fd#set_inlined;
      inlined_functions <- faddr :: inlined_functions;
      chlog#add "add inlined function" (faddr#toPretty)
    end

  method private add_trampoline (startaddr: doubleword_int) =
    begin
      trampolines <- startaddr :: trampolines;
      chlog#add "add trampoline" (LBLOCK [startaddr#toPretty])
    end

  method private add_inlined_block (faddr:doubleword_int) (baddr:doubleword_int) =
    let fd = functions_data#add_function faddr in
    begin
      fd#add_inlined_block baddr;
      chlog#add
        "add inlined block"
        (LBLOCK [faddr#toPretty; STR ": "; baddr#toPretty])
    end

  method has_esp_adjustment (faddr:doubleword_int) (iaddr:doubleword_int) =
    H.mem esp_adjustments_i iaddr#index ||
      (H.mem esp_adjustments (faddr#index, iaddr#index))

  method is_inlined_function (a:doubleword_int) =
    List.exists (fun i -> a#equal i) inlined_functions

  method is_trampoline (a: doubleword_int) =
    List.fold_left (fun acc startaddr ->
        acc || (startaddr#equal a)) false trampolines

  method get_esp_adjustment (faddr:doubleword_int) (iaddr:doubleword_int) =
    if H.mem esp_adjustments_i iaddr#index then
      H.find esp_adjustments_i iaddr#index
    else if H.mem esp_adjustments (faddr#index, iaddr#index) then
      H.find esp_adjustments (faddr#index, iaddr#index)
    else
      raise
        (BCH_failure
           (LBLOCK [
                STR "No esp adjustment found for ";
		faddr#toPretty;
                STR "@";
                iaddr#toPretty]))

  method has_call_target (faddr: doubleword_int) (iaddr: doubleword_int) =
    H.mem function_call_targets (faddr#index, iaddr#index)

  method get_call_target
           (faddr: doubleword_int) (iaddr: doubleword_int): call_target_t =
    if self#has_call_target faddr iaddr then
      H.find function_call_targets (faddr#index, iaddr#index)
    else
      raise
        (BCH_failure
           (LBLOCK [
                STR "No user call target found for ";
		faddr#toPretty;
                STR "@";
                iaddr#toPretty]))

  method has_indirect_jump_targets (faddr:doubleword_int) (iaddr:doubleword_int) =
    H.mem indirect_jump_targets (faddr#index, iaddr#index)

  method get_indirect_jump_targets (faddr:doubleword_int) (iaddr:doubleword_int) =
    if self#has_indirect_jump_targets faddr iaddr then
      H.find indirect_jump_targets (faddr#index, iaddr#index)
    else
      raise
        (BCH_failure
           (LBLOCK [
                STR "No indirect jump targets found for ";
                faddr#toPretty;
                STR "@";
                iaddr#toPretty]))

  method has_jump_table_target (faddr:doubleword_int) (iaddr:doubleword_int) =
    if H.mem jumptabletargets (faddr#index,iaddr#index) then
      let (jta,lb,ub) =  H.find jumptabletargets (faddr#index,iaddr#index) in
      let lboffset = 4 * lb in
      let uboffset = 4 * ub in
      let _ =
        if collect_diagnostics () then
          ch_diagnostics_log#add
            "user-provided jump-table target"
            (LBLOCK [
                 iaddr#toPretty;
                 STR ": ";
                 jta#toPretty;
                 STR " with offsets ";
                 INT lboffset;
                 STR " - ";
                 INT uboffset]) in
      List.exists
        (fun jt -> jt#includes_address (jta#add_int lboffset)) jumptables
    else
      false

  method get_jump_table_target (faddr:doubleword_int) (iaddr:doubleword_int) =
    if self#has_jump_table_target faddr iaddr then
      let (jta, lb, ub) = H.find jumptabletargets (faddr#index, iaddr#index) in
      let jt =
        let lboffset = 4 * lb in
        (try
           List.find
             (fun jt -> jt#includes_address (jta#add_int lboffset)) jumptables
         with
         | Not_found ->
            raise
              (BCH_failure
                 (LBLOCK [STR "internal error in get_jump_table_target"]))) in
      let jtstart = jt#get_start_address in
      let (lbnew, ubnew) =
        if jtstart#lt jta then
          fail_tfold
            (trerror_record
               (LBLOCK [STR "sytem_info#get_jump_table_target:"; iaddr#toPretty]))
            (fun i ->
              let diff = i / 4 in
              (lb + diff, ub + diff))
            (jta#subtract_to_int jtstart)
        else
          fail_tfold
            (trerror_record
               (LBLOCK [STR "system_info#get_jump_table_target:"; iaddr#toPretty]))
            (fun i ->
              let diff = i / 4 in
              (lb - diff, ub - diff))
            (jtstart#subtract_to_int jta) in

      let _ =
        if collect_diagnostics () then
          ch_diagnostics_log#add
            "user-provided jump-table target"
            (LBLOCK [
                 iaddr#toPretty;
                 STR ": ";
                 jtstart#toPretty;
                 STR " (";
                 INT lbnew;
                 STR ", ";
                 INT ubnew;
                 STR ")"]) in
      (jt, jta, lbnew, ubnew)
    else
      raise
        (BCH_failure
           (LBLOCK [
                STR "No jump-table targets found for ";
                faddr#toPretty;
                STR "@";
                iaddr#toPretty]))
 
  method private add_jump_table_target
                   (faddr: doubleword_int)
                   (iaddr: doubleword_int)
                   (jta: doubleword_int)
                   (lb: int)     (* lower bound index *)
                   (ub: int) =   (* upper bound index *)
    let _ =
      if collect_diagnostics () then
        ch_diagnostics_log#add
          "jump-table targets"
          (LBLOCK [
               STR "(";
               faddr#toPretty;
               STR ",";
               iaddr#toPretty;
               STR "): ";
               jta#toPretty]) in
    H.add jumptabletargets (faddr#index,iaddr#index) (jta, lb, ub)
   
  method get_lib_functions_loaded =
    H.fold (fun k v a -> (k,v) :: a) lib_functions_loaded []

  method get_user_data_block_count = user_data_blocks

  method get_user_struct_count = user_structs

  method get_user_nonreturning_count = user_nonreturning

  method get_user_class_count = user_classes

  method get_user_call_target_count = user_call_targets

  method add_exported_item_name (addr:doubleword_int) (name:string) =
    H.replace exported_item_names addr#index name 

  method is_class_member_function (faddr:doubleword_int) = 
    H.mem class_membership faddr#index

  method get_class_infos (faddr:doubleword_int) =
    try
      H.find class_membership faddr#index
    with
      Not_found -> 
	raise (BCH_failure (LBLOCK [ STR "No class names found for " ; 
				     faddr#toPretty ]))

  method private add_class_member 
    (faddr: doubleword_int)
    (classinfo: string * function_interface_t * bool) =
    let index = faddr#index in
    let (classname, fnintf, _) = classinfo in
    let entry =
      if H.mem class_membership index then
        H.find class_membership index
      else
        [] in
    let entry =
      if List.exists
           (fun (cname, fintf,_) ->
             cname = classname && fintf.fintf_name = fnintf.fintf_name) entry then
        entry
      else
	classinfo :: entry in
    H.replace class_membership index entry


  method set_filename s =
    begin filename <- s; system_data#set_filename s end

  method get_filename = filename

  method set_xfilesize s =
    begin xfilesize <- s; system_data#set_xfilesize s end

  method get_xfilesize = xfilesize

  method set_elf = is_elf <- true
  method is_elf = is_elf

  method set_mips = is_mips <- true
  method is_mips = is_mips

  method set_arm = is_arm <- true
  method is_arm = is_arm

  method set_power = is_power <- true
  method is_power = is_power

  (* system initialization :
     - load system_file (application specific, created by previous round)
     - load system_userdata (application specific, user-created )
     - load directory_file  (specification of export items, per directory)
     - set_functions_file_path (the invariants and finfos from the previous round)
  *)
    
  method initialize =
    begin
      self#initialize_system_file;
      self#initialize_type_definitions;
      self#initialize_user_data;
      self#initialize_annotation_data;
      self#initialize_user_directory_data;
      set_functions_file_path ()
    end

  method private initialize_system_file  =
    try
      match load_system_file () with
      | Some node -> 
         begin 
	   has_file <- true;
	   self#read_xml node;
	   chlog#add "initialization" (STR "system_info: initialization from file")
         end
      | _ -> ()
    with
    | XmlParseError (line, col, p)
    | XmlReaderError (line, col, p)
    | XmlDocumentError (line,col,p) ->
       let msg =
         LBLOCK [
             STR "Xml error in system-info-file (";
             INT line;
             STR ",";
             INT col;
             STR "): ";
             p] in
      begin
	ch_error_log#add "xml error in system-info file"  p;
	raise (XmlDocumentError (line, col, msg))
      end
      

  method private initialize_user_directory_data = ()

  method private initialize_annotation_data =
    match load_annotation_system_file () with
    | Some node ->
       begin
         self#read_xml_annotation_data node ;
         chlog#add
           "initialization"
           (STR "system_info: supplemented with annotation data")
       end
    | _ -> ()

  method private read_xml_annotation_data (node:xml_element_int) =
    let hasc = node#hasOneTaggedChild in
    let getc = node#getTaggedChild in
    begin
      (if hasc "data-blocks" then 
	  let dnode = getc "data-blocks" in
	  begin
	    self#read_xml_data_blocks dnode ;
	    user_data_blocks <- List.length dnode#getChildren
	  end)
    end
      

  method private initialize_user_data =
    match load_userdata_system_file () with
    | Some node ->
      begin
	self#read_xml_user_data node ;
	chlog#add
          "initialization" (STR "system_info: supplemented with user data")
      end
    | _ -> ()
      
  method private read_xml_user_data (node:xml_element_int) =
    let get = node#getAttribute in
    let has = node#hasNamedAttribute in
    let getc = node#getTaggedChild in
    let hasc = node#hasOneTaggedChild in
    begin
      (if has "app" then
         system_settings#set_app_summary_jars (get "app"));

      (if hasc "settings" then
	 self#read_xml_settings (getc "settings") );

      (if hasc "function-entry-points" then 
	 let fenode = getc "function-entry-points" in
	 self#read_xml_user_function_entry_points fenode);

      (if hasc "function-names" then 
	 self#read_xml_user_function_names (getc "function-names"));

      (if hasc "non-returning-functions" then 
	 let nrnode = getc "non-returning-functions" in
	 begin
	   self#read_xml_user_nonreturning_functions nrnode;
	   user_nonreturning <- List.length nrnode#getChildren
	 end);

      (if hasc "non-returning-calls" then
	 let nrnode = getc "non-returning-calls" in
	 begin
	   self#read_xml_nonreturning_calls nrnode
	 end);

      (if hasc "initialized-memory" then
         let inode = getc "initialized-memory" in
         self#read_xml_initialized_memory inode);

      (if hasc "readonly-ranges" then
	 let ronode = getc "readonly-ranges" in
	 begin
	   self#read_xml_readonly_ranges ronode
	 end);

      (if hasc "classes" then 
	 let cnode = getc "classes" in
	 begin
	   self#read_xml_classes cnode;
	   user_classes <- List.length cnode#getChildren
	 end);

      (if hasc "structs" then 
	 let snode = getc "structs" in
	 begin
	   self#read_xml_structs snode;
	   user_structs <- List.length snode#getChildren
	 end);

      (if hasc "data-blocks" then 
	 let dnode = getc "data-blocks" in
	 begin
	   self#read_xml_data_blocks dnode;
	   user_data_blocks <- List.length dnode#getChildren
	 end);

      (if hasc "call-targets" then
	  let cnode = getc "call-targets" in
	  begin
	    self#read_xml_call_targets cnode;
	    user_call_targets <- user_call_targets + List.length cnode#getChildren
	  end);

      (if hasc "struct-tables" then
         let stnode = getc "struct-tables" in
         begin
           self#read_xml_struct_tables stnode;
         end);

      (if hasc "call-back-tables" then
         let cbtnode = getc "call-back-tables" in
         begin
           self#read_xml_call_back_tables cbtnode;
         end);

      (if hasc "successors" then
         let snode = getc "successors" in
         begin
           self#read_xml_successors snode
         end);

      (if hasc "jump-table-targets" then
         let jnode = getc "jump-table-targets" in
         begin
           self#read_xml_jump_table_targets jnode
         end);

      (if hasc "indirect-jumps" then
         self#read_xml_indirect_jumps (getc "indirect-jumps"));

      (if hasc "arm-thumb" then
         self#read_xml_arm_thumb_switches (getc "arm-thumb"));

      (if hasc "encodings" then
         self#read_xml_encodings (getc "encodings"));

      (if hasc "cfnops" then
         self#read_xml_cfnops (getc "cfnops"));

      (if hasc "fixed-conditionals" then 
	 self#read_xml_fixed_true_conditionals (getc "fixed-conditionals"));

      (if hasc "excluded-jumptables" then 
	 self#read_xml_excluded_jumptables (getc "excluded-jumptables"));

      (if hasc "invalidated-jumptable-startaddresses" then
	  self#read_xml_invalidated_jumptable_startaddresses 
	    (getc "invalidated-jumptable-startaddresses"));

      (if hasc "jumptable-splits" then
         self#read_xml_jumptable_splits (getc "jumptable-splits"));

      (if hasc "virtual-function-tables" then
	  self#read_xml_virtual_function_tables
	    (getc "virtual-function-tables"));

      (if hasc "esp-adjustments" then
	  let enode = getc "esp-adjustments" in
	  self#read_xml_esp_adjustments enode) ;

      (if hasc "inlined-functions" then
         let inode = getc "inlined-functions" in
         self#read_xml_inlined_functions inode);

      (if hasc "inlined-blocks" then
         let inode = getc "inlined-blocks" in
         self#read_xml_inlined_blocks inode);

      (if hasc "trampoline-payloads" then
         let tnode = getc "trampoline-payloads" in
         self#read_xml_trampolines tnode);

      (if hasc "specializations" then
         specializations#read_xml (getc "specializations"));

      (if hasc "section-headers" then
         section_header_infos#read_xml (getc "section-headers"));

      (if hasc "esp-adjustments-i" then
	  let enode = getc "esp-adjustments-i" in
	  self#read_xml_esp_adjustments_i enode);

      (if hasc "use-struct-constants" then 
	 self#read_xml_structconstants (getc "use-struct-constants"));

      (if hasc "use-constants" then
         self#read_xml_constants_files (getc "use-constants"));

      (if hasc "symbolic-addresses" then 
	 read_xml_symbolic_addresses (getc "symbolic-addresses"));

      (if hasc "variable-introductions" then
         self#read_xml_variable_introductions (getc "variable-introductions"));

      (if hasc "userdeclared-codesections" then
	 self#read_xml_userdeclared_codesections
           (getc "userdeclared-codesections"));

      (if hasc "arg-constraints" then
         self#read_xml_argument_constraints (getc "arg-constraints"))
    end

  method private read_xml_initialized_memory (node:xml_element_int) =
    let getc = node#getTaggedChildren in
    List.iter (fun n ->
        let a = n#getAttribute "a" in
        let memstring = read_memory_string_file a in
        begin
          H.add initialized_memory a memstring ;
          chlog#add
            "initialized memory"
            (LBLOCK [
                 STR a;
                 STR ": ";
                 INT (String.length memstring);
                 STR " bytes"])
        end) (getc "mem")

  method private read_xml_settings (node:xml_element_int) =
    let getc = node#getTaggedChildren in
    begin
      List.iter (fun n ->
	let name = n#getAttribute "name" in
	match name with
	| "sideeffects-on-globals" -> 
	  let gvAffected = 
	    List.map (fun gn -> gn#getAttribute "a") (n#getTaggedChildren "gv") in
	  system_settings#disable_sideeffects_on_globals gvAffected
	| "abstract-stackvars" -> system_settings#set_abstract_stackvars_disabled ;
	| _ ->
           raise (BCH_failure 
		    (LBLOCK [ STR "System setting disable not recognized: " ;
                              STR name ])))
	(getc "disable") ;
      List.iter (fun n ->
	let name = n#getAttribute "name" in
	match name with
	| "sideeffects-on-globals" ->
           let gvAffected =
	     List.map
               (fun gn -> gn#getAttribute "a") (n#getTaggedChildren "gv") in
	   system_settings#enable_sideeffects_on_globals gvAffected
	| _ ->
           raise (BCH_failure
		    (LBLOCK [ STR "System setting enable not recognized: " ;
                              STR name ])))
	(getc "enable")
    end

  method private read_xml_indirect_jumps (node:xml_element_int) =
    let getc = node#getTaggedChildren in
    List.iter (fun n ->
        let geta tag = geta_fail "read_xml_indirect_jumps" n tag in
        let getc = n#getTaggedChildren in
        let fa = geta "fa" in
        let ia = geta "ia" in
        let tgts =
          List.map (fun nn ->
              geta_fail "read_xml_indirect_jumps" nn "a")
            (getc "tgt") in
        H.add indirect_jump_targets (fa#index, ia#index) tgts) (getc "jumpinstr")

  method private read_xml_cfnops (node:xml_element_int) =
    List.iter (fun n ->
      let get = n#getAttribute in
      let geta n tag = geta_fail "read_xml_cfnops" n tag in
      let has = n#hasNamedAttribute in
      let startaddr = geta n "start" in
      let endaddr = geta n "end" in
      let desc = get "desc" in
      if endaddr#le startaddr then
	raise
          (BCH_failure
	     (LBLOCK [
                  STR "Invalid range for cfnop start address ";
		  startaddr#toPretty]))
      else
	let len =
          fail_tvalue
            (trerror_record (STR "system_info:read_xml_cfnops"))
            (endaddr#subtract_to_int startaddr) in
	if has "jmp" then
	  let jmpaddr = geta n "jmp" in
	  H.add cfjmps startaddr#index (jmpaddr,len,desc)
	else
          let _ =
            chlog#add
              "cfnop"
              (LBLOCK [
                   startaddr#toPretty;
                   STR " (length: ";
                   INT len;
                   STR "; ";
                   STR desc;
                   STR ")"]) in
	  H.add cfnops startaddr#index (len,desc)) (node#getTaggedChildren "nop")

  method is_cfnop (a:doubleword_int) = H.mem cfnops a#index

  method get_cfnop (a:doubleword_int) = 
    if H.mem cfnops a#index then H.find cfnops a#index else
      raise (BCH_failure (LBLOCK [ STR "No cfnop found at " ; a#toPretty ]))  

  method is_cfjmp (a:doubleword_int) = H.mem cfjmps a#index

  method get_cfjmp (a:doubleword_int) =
    if H.mem cfjmps a#index then H.find cfjmps a#index else
      raise (BCH_failure (LBLOCK [ STR "No cfjmp found at " ; a#toPretty ]))

  method private read_xml_jumptables (node:xml_element_int) =
    let tls = mk_tracelog_spec "system_info#read_xml_jumptables" in
    jumptables <-
      List.fold_left (fun acc jtc ->
          log_tfold
            tls
            ~ok:(fun jt -> jt::acc)
            ~error:(fun _ -> acc)
            (read_xml_jumptable jtc)) [] (node#getTaggedChildren "jt")

  method private read_xml_data_blocks (node:xml_element_int) =
    let tls = mk_tracelog_spec "system_info#read_xml_data_blocks" in
    let dbs =
      List.fold_left (fun acc dbc ->
          log_tfold
            tls
            ~ok:(fun db -> db::acc)
            ~error:(fun _ -> acc)
            (read_xml_data_block dbc)) [] (node#getTaggedChildren "db") in
    data_blocks#addList dbs

  method private read_xml_user_function_entry_points (node:xml_element_int) =
    List.iter (fun n ->
        let fa = geta_fail "read_xml_user_function_entry_points" n "a" in
        if functions_data#is_function_entry_point fa then () else
          ignore (functions_data#add_function fa))
      (node#getTaggedChildren "fe")

  method private read_xml_call_target(node: xml_element_int): call_target_t =
    let get = node#getAttribute in
    let geti = node#getIntAttribute in
    let geta tag = geta_fail "read_xml_call_target" node tag in
    match get "ctag" with
    | "dll" ->
       let dll = get "dll" in
       let name = get "name" in
       let _ = self#add_lib_function_loaded dll name in
       StubTarget (DllFunction (dll, name))
    | "so" -> StubTarget (SOFunction (get "name"))
    | "jni" -> StubTarget (JniFunction (geti "index"))
    | "app" -> AppTarget (geta "appa")
    | "cbt" -> CallbackTableTarget (geta "cba", geti "offset")
    | s ->
       raise
         (BCH_failure
            (LBLOCK [
                 STR "Call target tag ";
                 STR s;
                 STR " not recognized"]))

  method private read_xml_call_target_callsite (node: xml_element_int) =
    let geta tag = geta_fail "read_xml_call_target_callsite" node tag in
    let faddr = geta "fa" in
    let iaddr = geta "ia" in
    let tgts = List.map self#read_xml_call_target (node#getTaggedChildren "tgt") in
    let callsitetgt = match List.length tgts with
      | 0 ->
         raise
           (BCH_failure
              (LBLOCK [
                   STR "Found zero targets for call targets at ";
                   faddr#toPretty;
                   STR ", ";
                   iaddr#toPretty]))
      | 1 -> List.hd tgts
      | _ -> IndirectTarget (None, tgts) in
    H.add function_call_targets (faddr#index, iaddr#index) callsitetgt

  method private read_xml_call_targets (node: xml_element_int) =
    (* <call-targets>
         <callsite fa= ia=
             <tgt ctag=[dll|so|jni|app|cbt]
                       [dll= | appa= | index= | name= | cba=, offset=]/>
             <tgt ... />
             ...
         </callsite>
         <callsite fa= ia=
             <...>
         </callsite>
         ....
     *)
    List.iter
      self#read_xml_call_target_callsite (node#getTaggedChildren "callsite")

  method private read_xml_struct_tables (node: xml_element_int) =
    (* <struct-tables>
          <st name={name} va=0x... size={size}>
     *)
    List.iter
      (fun stnode ->
        let vname = stnode#getAttribute "name" in
        let va = stnode#getAttribute "va" in
        let size = stnode#getIntAttribute "size" in
        structtables#add_table_address va vname size)
    (node#getTaggedChildren "st")

  method private read_xml_call_back_tables (node: xml_element_int) =
    (* <call-back-tables>
         <cbt name={name} va=0x...>
         ...
     *)
    List.iter
      (fun cbtnode ->
        let vname = cbtnode#getAttribute "name" in
        let va = cbtnode#getAttribute "va" in
        callbacktables#add_table_address va vname)
      (node#getTaggedChildren "cbt")

  method private read_xml_jump_table_targets (node:xml_element_int) =
    List.iter (fun n ->
        let geti = n#getIntAttribute in
        let geta n tag = geta_fail "read_xml_jump_table_targets" n tag in
        let faddr = geta n "fa" in
        let iaddr = geta n "ia" in
        let jta = geta n "jt" in
        let lb = geti "lb" in
        let ub = geti "ub" in
        self#add_jump_table_target faddr iaddr jta lb ub)
      (node#getTaggedChildren "tgt")

  method private read_xml_successors (node: xml_element_int) =
    (* Expected format:
       <successors>
          <instr ia="0xaaaaa"
                 ss="0x1a,0x2a....."/>
       </successors> *)
    List.iter (fun n ->
        let get = n#getAttribute in
        let ia = get "ia" in
        let ss = get "ss" in
        let addrs =
          List.map
            (fun s ->
              fail_tvalue
                (trerror_record
                   (LBLOCK [STR "read_xml_successors: "; STR s]))
                (string_to_doubleword s))
            (nsplit ',' ss) in
        let _ =
          chlog#add
            "add successors"
            (LBLOCK [STR "Instruction at "; STR ia]) in
        H.add successors ia addrs)
      (node#getTaggedChildren "instr")
 
  method private read_xml_encodings (node:xml_element_int) =
    List.iter (fun n ->
      let get = n#getAttribute in
      let geti = n#getIntAttribute in
      let getx tag = geta_fail "read_xml_encodings" n tag in
      let encoding_to_pretty (ty, va, size, key, width) =
	LBLOCK [
            STR "(";
            STR ty;
            STR ",";
            va#toPretty;
            STR ",";
            size#toPretty;
	    STR ",";
            key#toPretty;
            STR ",";
            INT width;
            STR ")"] in
      let c = (get "type", getx "va", getx "size", getx "key", geti "width") in
      begin
	chlog#add "add encoding"  (encoding_to_pretty c) ;
	encodings <- c :: encodings
      end) (node#getTaggedChildren "encoding")

  method private read_xml_arm_thumb_switches (node: xml_element_int) =
    let _ =
      if List.length (node#getTaggedChildren "switch") > 0 then
        system_settings#set_thumb in
    begin
      List.iter (fun n ->
          let get = n#getAttribute in
          let iaddr = get "ia" in
          let tgtarch = get "tgt" in
          let iaddr = TR.tget_ok (string_to_doubleword iaddr) in
          H.add arm_thumb_switches iaddr#index tgtarch)
        (node#getTaggedChildren "switch");
      chlog#add
        "arm-thumb userdata"
        (LBLOCK [
             STR "Arm-thumb switches: ";
             INT (List.length (node#getTaggedChildren "switch"))])
    end

  method private read_xml_fixed_true_conditionals (node:xml_element_int) = ()

  method private read_xml_excluded_jumptables (node:xml_element_int) =
    List.iter (fun n ->
      let getx tag = geta_fail "read_xml_excluded_jumptables" n tag in
      let jtaddr = getx "a" in
      begin
	chlog#add "exclude jumptable" jtaddr#toPretty;
	excluded_jumptables#add jtaddr
      end) (node#getTaggedChildren "jt")

  method private read_xml_invalidated_jumptable_startaddresses
                   (node:xml_element_int) =
    List.iter (fun n ->
      let getx tag =
        geta_fail "read_xml_invalidated_jumptable_startaddresses" n tag in
      let jtaddr = getx "a" in
      begin
	chlog#add "invalidate jumptable startaddress" jtaddr#toPretty;
	invalidated_jumptable_startaddresses#add jtaddr
      end) (node#getTaggedChildren "jt")

  method private read_xml_jumptable_splits (node:xml_element_int) =
    List.iter (fun n ->
        let get = n#getAttribute in
        let jtaddr = get "a" in
        let sizes = List.map int_of_string (nsplit ',' (get "sizes")) in
          begin
            chlog#add "split jumptable" (STR jtaddr);
            H.add jumptable_splits jtaddr sizes
          end) (node#getTaggedChildren "jt")

  method private has_jumptable_splits (a:doubleword_int) =
    H.mem jumptable_splits a#to_hex_string

  method private get_jumptable_splits (a:doubleword_int) =
    let a = a#to_hex_string in
    if H.mem jumptable_splits a then
      H.find jumptable_splits a
    else
      raise
        (BCH_failure
           (LBLOCK [STR "No jumptable splits found for "; STR a]))

  method private read_xml_virtual_function_tables (node:xml_element_int) =
    List.iter (fun n ->
      let getx tag = geta_fail "read_xml_virtual_function_tables" n tag in
      let jtaddr = getx "a" in
      if self#has_jumptable jtaddr then
	begin
	  chlog#add "set virtual function table" jtaddr#toPretty ;
	  self#set_virtual_function_table jtaddr
	end
      else
	ch_error_log#add "set virtual function table"
	  (LBLOCK [ STR "No jump table found at "; jtaddr#toPretty ]))
      (node#getTaggedChildren "vft")

  method private read_xml_argument_constraints (node: xml_element_int) =
    (* format: <fn a=hex-addr>
                 <c n=arg-name offset=offset lb=lb ub=ub v=v>

       where arg-name may also be the address of a global variable
     *)
    List.iter (fun n ->
        let get = n#getAttribute in
        let faddr = get "a" in
        List.iter (fun nc ->
            let getn = nc#getAttribute in
            let geti = nc#getIntAttribute in
            let has = nc#hasNamedAttribute in
            let name = getn "n" in
            let lb =
              if has "lb" then
                Some (geti "lb")
              else if has "v" then
                Some (geti "v")
              else
                None in
            let ub =
              if has "ub" then
                Some (geti "ub")
              else if has "v" then
                Some (geti "v")
              else None in
            let offset =
              if has "offset" then
                Some (geti "offset")
              else
                None in
            self#add_argument_constraint faddr name offset lb ub)
          (n#getTaggedChildren "c"))
      (node#getTaggedChildren "fn")

  method private add_argument_constraint
                   (faddr: string)
                   (name: string)
                   (offset: int option)
                   (lb: int option)
                   (ub: int option) =
    let entry =
      if H.mem argument_constraints faddr then
        H.find argument_constraints faddr
      else
        let e = H.create 3 in
        begin
          H.add argument_constraints faddr e;
          e
        end in
    if H.mem entry (name, offset) then
      ()
    else
        let popt (tag: string)  (i: int option) =
          match i with
          | Some i -> LBLOCK [STR tag; STR ":"; INT i; STR "; "]
          | _ -> STR "" in
        begin
          chlog#add
            "argument constraint"
            (LBLOCK [
                 STR faddr;
                 STR ". ";
                 STR name;
                 STR ": ";
                 (popt "offset" offset);
                 (popt "lb" lb);
                 (popt "ub" ub)]);
          H.add entry (name, offset) (lb, ub)
        end

  method has_argument_constraints (faddr: string): bool =
    H.mem argument_constraints faddr

  method get_argument_constraints
           (faddr: string): (string * int option * int option * int option) list =
    if H.mem argument_constraints faddr then
      let args = H.find argument_constraints faddr in
      H.fold (fun (k, offset) (lb, ub) a -> (k, offset, lb, ub) :: a) args []
    else
      []

  method private read_xml_userdeclared_codesections (node:xml_element_int) =
    List.iter (fun n ->
      let getx tag = geta_fail "read_xml_userdeclared_codesections" n tag in
      let va = getx "va" in
      let size = getx "size" in
      begin
	chlog#add "add user-declared code section" va#toPretty;
	userdeclared_codesections#set va size
      end) (node#getTaggedChildren "code")

  method private read_xml_esp_adjustments (node:xml_element_int) =
    List.iter (fun n ->
      let geta n tag = geta_fail "read_xml_esp_adjustments" n tag in
      let faddr = geta n "fa" in
      let iaddr = geta n "ia" in
      let adj = n#getIntAttribute "adj" in
      self#add_esp_adjustment faddr iaddr adj) (node#getTaggedChildren "esp-adj")

  method private read_xml_esp_adjustments_i (node:xml_element_int) =
    List.iter (fun n ->
      let geta n tag = geta_fail "read_xml_esp_adjustments_i" n tag in
      let iaddr = geta n "ia" in
      let adj = n#getIntAttribute "adj" in
      self#add_esp_adjustment_i iaddr adj) (node#getTaggedChildren "esp-adj")

  method private read_xml_inlined_functions (node:xml_element_int) =
    List.iter (fun n ->
        let geta n tag = geta_fail "read_xml_inlined_functions" n tag in
        let faddr = geta n "fa" in
        let _ = chlog#add "add inlined function" faddr#toPretty in
        self#add_inlined_function faddr) (node#getTaggedChildren "inline")

  method private read_xml_trampolines (node: xml_element_int) =
    List.iter (fun n ->
        let geta n tag = geta_fail "read_xml_trampolines" n tag in
        let startaddr = geta n "a" in
        let _ =
          chlog#add
            "add trampoline"
            (LBLOCK [startaddr#toPretty]) in
        self#add_trampoline startaddr) (node#getTaggedChildren "trampoline")

  method private read_xml_inlined_blocks (node:xml_element_int) =
    List.iter (fun n  ->
        let geta n tag = geta_fail "read_xml_inlined_blocks" n tag in
        let faddr = geta n "fa" in
        let baddr = geta n "ba" in
        let _ =
          chlog#add
            "set inlined block"
            (LBLOCK [faddr#toPretty; STR ":"; baddr#toPretty]) in
        self#add_inlined_block faddr baddr) (node#getTaggedChildren "inline")

  method private read_xml_readonly_ranges (node:xml_element_int) =
    List.iter (fun n ->
        let geta n tag = geta_fail "read_xml_readonly_ranges" n tag in
        let s = geta n "start" in
        let e = geta n "end" in
        begin
	  readonly_ranges <- (s, e) :: readonly_ranges;
          chlog#add
            "readonly range"
            (LBLOCK [s#toPretty; STR " - "; e#toPretty])
        end)
      (node#getTaggedChildren "ror")

  (* reads type definitions from the bchsummaries jar. *)
  method initialize_type_definitions =
    try
      let filename = "typedefinitions" in
      let path = system_settings#get_summary_paths in
      if has_summary_file path filename then
	let xstring = get_summary_file path filename in
	let doc = readXmlDocumentString xstring in
	let root = doc#getRoot in
	let node = root#getTaggedChild "type-definitions" in
	List.iter (fun n ->
	  let name = n#getAttribute "tname" in
	  let ty = read_xml_type (n#getTaggedChild "type") in
	  begin
	    type_definitions#add_typeinfo name ty;
	    match ty with
	    | TCppComp (SimpleName cname, [], _) ->
               self#read_xml_struct_file cname
	    | _ -> ()
	  end) (node#getTaggedChildren "type-info")
      else
	ch_error_log#add "initialization" (STR "No type definitions found")
    with
    | XmlParseError (line,col,p)
    | XmlReaderError (line,col,p)
    | XmlDocumentError (line,col,p) ->
      begin
	ch_error_log#add "xml error in type definitions"  p;
	raise (XmlDocumentError (line,col,p))
      end

  method read_xml_constant_file (name:string) =
    try
      if List.mem name constant_files then () else
	let _ = constant_files <- name :: constant_files in
	let filename = "constants/" ^ name in
	let path = system_settings#get_summary_paths in
	if has_summary_file path filename then
	  let cstring = get_summary_file path filename in
	  let doc = readXmlDocumentString cstring in
	  let root = doc#getRoot in
	  if root#hasOneTaggedChild "symbolic-constants" then
	    let node = root#getTaggedChild "symbolic-constants" in
	    read_xml_symbolic_constants node
	  else if root#hasOneTaggedChild "symbolic-flags" then
	    let node = root#getTaggedChild "symbolic-flags" in
	    read_xml_symbolic_flags node
	  else
	    raise
              (BCH_failure 
		 (LBLOCK [
                      STR "Symbolic constant file ";
                      STR filename;
		      STR " has neither constants nor flags specified"]))
	else
	  chlog#add "symbolic constants" (LBLOCK [STR name; STR " not found"])
    with
    | XmlParseError (line,col,p)
    | XmlReaderError (line,col,p)
    | XmlDocumentError (line,col,p) ->
      let msg = LBLOCK [STR name; STR ": "; p] in
      begin
	ch_error_log#add "xml error" msg ;
	raise (XmlDocumentError (line, col, msg))
      end

  method private read_xml_struct_file (name:string) =
    try
      let filename = "structs/" ^ name in
      let path = system_settings#get_summary_paths in
      if has_summary_file path filename then
	let cstring = get_summary_file path filename in
	let doc = readXmlDocumentString cstring in
	let root = doc#getRoot in
	let node = root#getTaggedChild "struct" in
	let cinfo = read_xml_summary_struct node in
	(* let enums = get_struct_field_enums cinfo in *)
        let enums = [] in
	begin
	  List.iter self#read_xml_constant_file enums;
	  type_definitions#add_compinfo name cinfo
	end
      else
	ch_error_log#add
          "initialization"
	  (LBLOCK [STR "No struct definition found for "; STR name])
    with
    | XmlParseError (line, col, p)
    | XmlReaderError (line, col, p)
    | XmlDocumentError (line, col, p) ->
      let msg = LBLOCK [STR name; STR ": "; p] in
      begin
	ch_error_log#add "xml error" msg ;
	raise (XmlDocumentError (line, col, msg))
      end


  method private read_xml_constants_files (node:xml_element_int) =
    let getcc = node#getTaggedChildren in
    List.iter (fun n ->
      let name = n#getAttribute "name" in
      self#read_xml_constant_file name) (getcc "type")

  method private read_xml_user_function_names (node:xml_element_int) =
    let get n = n#getAttribute in
    let getcc = node#getTaggedChildren in
    let geta n = geta_fail "read_xml_user_function_names" n "a" in
    List.iter (fun n -> 
      let fa = geta n in
      let name = get n "n" in
      (functions_data#add_function fa)#add_name name) (getcc "fn")

  method private read_xml_variable_introductions (node: xml_element_int) =
    let geta n =
      fail_tvalue
        (trerror_record
           (LBLOCK [
                STR "read_xml_variable_introductions";
                STR (n#getAttribute "ia")]))
        (string_to_doubleword (n#getAttribute "ia")) in
    let getcc = node#getTaggedChildren in
    begin
      List.iter (fun n ->
          let iaddr = geta n in
          let name = n#getAttribute "name" in
          H.add variable_intros iaddr#index name) (getcc "vintro");
      chlog#add
        "initialization"
        (LBLOCK [
             STR "system-info: read ";
             INT (H.length variable_intros);
             STR " variable introductions"])
    end

  method private write_xml_variable_introductions (node: xml_element_int) =
    let vintros = H.fold (fun k v a -> (k, v)::a) variable_intros [] in
    List.iter (fun (dwindex, name) ->
        let vnode = xmlElement "vintro" in
        begin
          vnode#setAttribute "ia" (TR.tget_ok (int_to_doubleword dwindex))#to_hex_string;
          vnode#setAttribute "name" name;
          node#appendChildren [vnode];
        end) vintros

  method private read_xml_user_nonreturning_functions (node:xml_element_int) =
    let geta n =
      fail_tvalue
        (trerror_record
           (LBLOCK [
                STR "read_xml_user_nonreturning_functions: ";
                STR (n#getAttribute "a")]))
        (string_to_doubleword (n#getAttribute "a")) in
    let getcc = node#getTaggedChildren in
    List.iter (fun n ->
        let fd = functions_data#add_function (geta n) in
        let _ =
          chlog#add "user-declared non-returning function" (geta n)#toPretty in
        fd#set_non_returning) (getcc "nr")

  method private read_xml_nonreturning_calls (node:xml_element_int) =
    let geta n tag = geta_fail "read_xml_nonreturning_functions" n tag in
    let getcc = node#getTaggedChildren in
    List.iter (fun n -> 
      let fa = geta n "fa" in
      let ia = geta n "ia" in
      let _ = chlog#add "user-defined nonreturning call"
	(LBLOCK [ fa#toPretty ; STR ", " ; ia#toPretty ]) in
      match nonreturning_calls#get fa with
      | Some s -> s#add ia
      | _ ->
	let s = new DoublewordCollections.set_t in
	begin s#add ia; nonreturning_calls#set fa s end) (getcc "nrc")

  method private read_xml_classes (node:xml_element_int) =
    List.iter add_user_cpp_class_file 
      (List.map
         (fun n -> n#getAttribute "name") (node#getTaggedChildren "cls"))

  (* expects files in the structs directory for each named struct. *)
  method private read_xml_structs (node:xml_element_int) =
    List.iter add_user_c_struct
      (List.map
         (fun n -> n#getAttribute "name") (node#getTaggedChildren "struct"))

  method private read_xml_structconstants (node:xml_element_int) =
    List.iter (fun n ->
      let name = n#getAttribute "name" in
      match load_userdata_structconstant_file name with
      | Some scNode ->
	let sc = read_xml_cstructconstant scNode in
	begin
	  add_structconstant name sc;
	  chlog#add "c struct constant" (STR name)
	end
      | _ ->
	begin
	  ch_error_log#add "struct constant file not found" (STR name);
	  raise
            (BCH_failure
               (LBLOCK [
                    STR "Struct constant file for ";
                    STR name;
		    STR " not found"]))
	end)
      (node#getTaggedChildren "sc")
	

  method private read_xml_loaded_dlls (node:xml_element_int) =
    List.iter (fun dNode ->
      let dll = dNode#getAttribute "name" in
      List.iter (fun fNode ->
	self#add_lib_function_loaded dll (fNode#getAttribute "fname"))
	(dNode#getTaggedChildren "fn"))
      (node#getTaggedChildren "dll")

  method private read_xml_thread_start_functions (node:xml_element_int) =
    let geta n tag = geta_fail "read_xml_thread_start_functions" n tag in
    let get n tag = n#getAttribute tag in
    List.iter (fun saNode ->
      let sa = geta saNode "start-address" in
      List.iter (fun cNode ->
	let faddr = geta cNode "fa" in
	let iaddr = get cNode "ia" in
	let args = List.map id#read_xml_bterm (cNode#getTaggedChildren "arg") in
	self#set_thread_start_address faddr iaddr sa args
      ) (saNode#getTaggedChildren "creator")
    ) (node#getTaggedChildren "thread-start-function")

  method private read_xml_goto_returns (node:xml_element_int) =
    List.iter (fun gNode ->
        let geta tag = geta_fail "read_xml_goto_returns" gNode tag in
        let iaddr = geta "ia" in
        let tgt = geta "tgt" in
        self#add_goto_return iaddr tgt) (node#getTaggedChildren "goto")
          
  method private read_xml (node:xml_element_int) =
    let getc = node#getTaggedChild in
    let hasc = node#hasOneTaggedChild in
    begin
      functions_data#read_xml (getc "functions-data") ;
      self#read_xml_jumptables (getc "jump-tables") ;
      self#read_xml_data_blocks (getc "data-blocks") ;
      (if hasc "classes" then self#read_xml_classes (getc "classes")) ;
      (if hasc "structs" then self#read_xml_structs (getc "structs")) ;
      (if hasc "struct-constants" then
         self#read_xml_structconstants (getc "struct-constants"));
      (if hasc "loaded-dlls" then self#read_xml_loaded_dlls (getc "loaded-dlls")) ;
      (if hasc "string-xreferences" then
         string_table#read_xml (getc "string-xreferences")) ;
      (if hasc "thread-start-functions" then
	  self#read_xml_thread_start_functions (getc "thread-start-functions")) ;
      (if hasc "goto-returns" then
         self#read_xml_goto_returns (getc "goto-returns"));
      (if hasc "variable-introductions" then
         self#read_xml_variable_introductions (getc "variable-introductions"))
    end
      
  method get_userdeclared_codesections = userdeclared_codesections#listOfKeys
      
   (* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
    *                                     stage 1: jump-tables and data-blocks *
    * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

  method private is_excluded_jumptable (iaddr:doubleword_int) =
    excluded_jumptables#has iaddr

  method private has_invalid_startaddress (iaddr:doubleword_int) =
    invalidated_jumptable_startaddresses#has iaddr
      
  method initialize_jumptables 
    (is_code_address:doubleword_int -> bool) 
    (read_only_section_strings:(doubleword_int * string) list) = 
    let default () =
      if system_settings#is_set_vftables_enabled then
        List.iter (fun jt ->
	 if (List.exists functions_data#is_function_entry_point jt#get_all_targets) then
	   self#set_virtual_function_table jt#get_start_address) self#get_jumptables in
    if has_file then default () else
      match jumptables with
      | [] -> 
	let l =  find_jumptables ~is_code_address ~read_only_section_strings in
	let l = List.filter 
	          (fun jt -> not (self#is_excluded_jumptable jt#get_start_address)) l in
        let l = List.fold_left
                  (fun acc jt ->
                    if self#has_jumptable_splits jt#get_start_address then
                      let sizes = self#get_jumptable_splits jt#get_start_address in
                      let jts = split_jumptable ~jumptable:jt ~sizes in
                      jts @ acc
                    else
                      jt::acc) [] l in
	let _ = List.iter (fun jt ->
	  if self#has_invalid_startaddress jt#get_start_address then
	    jt#invalidate_startaddress) l in
	begin
	  jumptables <- l  ;
	  default ()
	end
      | _ -> default ()

  method initialize_datablocks
    (read_only_section_strings:(doubleword_int * string) list) = 
    if has_file then () else
      let _ = pr_debug [ STR "Initialize data blocks " ; NL ] in
      data_blocks#addList (find_seh4_structures read_only_section_strings)

	
  method get_jumptables = jumptables

  method get_jumptable (addr:doubleword_int) =
    try
      List.find (fun jt -> jt#get_start_address#equal addr) jumptables
    with
      Not_found ->
      raise
        (BCH_failure
	   (LBLOCK [STR "No jump table found for "; addr#toPretty]))

  method set_virtual_function_table (jtaddr:doubleword_int) =
    let targets = (self#get_jumptable jtaddr)#get_all_targets in
    begin
      chlog#add
        "add virtual functions"
	(LBLOCK [
             STR "add ";
             INT (List.length targets);
	     STR " function entry points for table at ";
             jtaddr#toPretty]);
      List.iter (fun vf ->
          let _ = pverbose [STR "add virtual function: "; vf#toPretty; NL] in
          (functions_data#add_function vf)#set_virtual) targets
    end

  method add_jumptable (jt:jumptable_int) = jumptables <- jt :: jumptables
    
  method private write_xml_jumptables (node:xml_element_int) =
    node#appendChildren
      (List.map (fun j ->
           let jNode = xmlElement "jt" in
           begin
             j#write_xml jNode;
             jNode
           end) jumptables)

  method has_data_block (addr:doubleword_int) =
    List.exists (fun db -> db#get_start_address#equal addr) data_blocks#toList

  method is_in_data_block (addr:doubleword_int) =
    try
      Some (List.find (fun db ->
                db#get_start_address#le addr && addr#lt db#get_end_address)
	      data_blocks#toList)
    with 
      Not_found ->  None

  method is_in_jumptable (addr:doubleword_int) =
    try
      Some (List.find (fun jt -> jt#includes_address addr) jumptables)
    with
      Not_found -> None
	      
  method get_data_block (addr:doubleword_int) =
    try
      List.find (fun db -> db#get_start_address#equal addr) data_blocks#toList
    with
      Not_found ->
	raise (BCH_failure
		  (LBLOCK [ STR "No data block found for " ; addr#toPretty ]))

  method has_jumptable (addr:doubleword_int) =
    List.exists (fun jt -> jt#get_start_address#equal addr) jumptables

  method add_data_block (db:data_block_int) = 
    begin
      data_blocks#add db;
      (if collect_diagnostics () then
         chlog#add
           "add data block"
	   (LBLOCK [
                db#get_start_address#toPretty;
                STR " - ";
	        db#get_end_address#toPretty;
                STR ": ";
                STR db#get_name]))
    end
      
  method get_data_blocks = data_blocks#toList

  method set_jump_target (jaddr:doubleword_int) (base:doubleword_int)
    (jt:jumptable_int) (db:data_block_int) =
    H.add jumptargets jaddr#index (base,jt,db)

  method has_jump_target (jaddr:doubleword_int) = H.mem jumptargets jaddr#index

  method get_jump_target (jaddr:doubleword_int) =
    try
      H.find jumptargets jaddr#index
    with
    | Not_found ->
      raise
        (BCH_failure
	   (LBLOCK [STR "No jump target found at "; jaddr#toPretty]))
    
  method private write_xml_data_blocks (node:xml_element_int) =
    node#appendChildren (List.map (fun d -> 
      let dNode = xmlElement "db" in 
      begin
        d#write_xml dNode;
        dNode
      end) data_blocks#toList)


  method has_variable_intro (iaddr: doubleword_int) =
    H.mem variable_intros iaddr#index

  method get_variable_intro_name (iaddr: doubleword_int): string =
    if self#has_variable_intro iaddr then
      H.find variable_intros iaddr#index
    else
      raise
        (BCH_failure
           (LBLOCK [STR "No variable intro found for address "; iaddr#toPretty]))
      
  (* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
   *                                            stage 2: function entry points *
   * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
      
  method initialize_function_entry_points
           (collect_targets:unit -> doubleword_int list) =
    if has_file then
      begin
        pverbose [STR "Initialize functions from file"; NL];
        chlog#add
          "initialization"
	  (STR "system-info: initialization of function entry points from file")
      end
    else
      let feps = collect_targets () in
      begin
	chlog#add
          "initialization"
	  (LBLOCK [
               STR "system-info: collected ";
               INT (List.length feps);
	       STR " function entry points"]);
	List.iter
          (fun fe ->
            let fd = functions_data#add_function fe in
            if self#is_trampoline fe then
              fd#set_inlined
            else
              ()) feps
      end

  method is_nonreturning_call (fa:doubleword_int) (ia:doubleword_int) =
    match nonreturning_calls#get fa with
    | Some s -> s#has ia
    | _ -> false

  (* true if the condition of a conditional jump is guaranteed to be true *)
  method is_fixed_true_branch (a:doubleword_int) = fixedtrueconditionals#has a

  (* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
   *                                                             function names *
   * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
                                                 
  method get_exported_item_name (a:doubleword_int) = 
    if H.mem exported_item_names a#index then
      H.find exported_item_names a#index
    else
      raise
        (BCH_failure
           (LBLOCK [STR "No exported item name found for "; a#toPretty]))

  method has_exported_item_name (a:doubleword_int) = 
    H.mem exported_item_names a#index

  method get_exported_data_spec (name:string) =
    if self#has_exported_data_spec name then
      H.find data_export_specs name 
    else
      raise (BCH_failure (LBLOCK [STR "No export spec found for "; STR name]))
	
  method has_exported_data_spec (name:string) = H.mem data_export_specs name

  (* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ goto returns ~ *)

  method add_goto_return (iaddr:doubleword_int) (tgt:doubleword_int) =
    begin
      goto_returns#set iaddr tgt ;
      chlog#add
        "add goto return"
        (LBLOCK [iaddr#toPretty; STR ": "; tgt#toPretty])
    end

  method is_goto_return (iaddr:doubleword_int) = 
    match goto_returns#get iaddr with Some _ -> true | _ -> false

  method get_goto_return (iaddr:doubleword_int) =
    match goto_returns#get iaddr with
    | Some tgt -> tgt
    | _ ->
       raise
         (BCH_failure
            (LBLOCK [STR "No goto-return found for "; iaddr#toPretty]))
      
  (* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
   *                                                          file information *
   * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
  val mutable file_stream_wrapper_function = make_little_endian_stream_wrapper
  val mutable little_endian = true
  val mutable image_base = wordzero
  val mutable base_of_code_rva = wordzero
  val mutable code_size = wordzero
  val mutable is_code_address = (fun _ -> false)
  val mutable address_of_entry_point = wordzero
  val locked_instructions = new DoublewordCollections.set_t
  val bound_library_functions = H.create 13
    
  method set_file_string (s:string) = file_as_string := s

  method set_big_endian = 
    begin
      little_endian <- false ;
      file_stream_wrapper_function <- make_big_endian_stream_wrapper
    end

  method is_little_endian = little_endian

  method set_elf_is_code_address (lb:doubleword_int) (ub:doubleword_int) =
    is_code_address <- (fun a -> lb#le a  && a #lt ub)

  method set_code_size (s:doubleword_int) = 
    let low = image_base#add base_of_code_rva in
    let high = low#add s in
    begin
      code_size <- s ;
      is_code_address <- (fun a -> low#le a && a#lt high)
    end

  method get_code_size = 
    List.fold_left
      (fun acc cs -> acc#add cs)
      code_size userdeclared_codesections#listOfValues

  method get_size = String.length !file_as_string

  method get_file_input ?(hexSize=wordzero) (hexOffset:doubleword_int) =
    let fString = self#get_file_string ~hexSize hexOffset in
    file_stream_wrapper_function (IO.input_string fString)

  method private get_encodings (va:doubleword_int) (len:int) =
    let encoding_to_pretty (ty, va, size, key, width) =
      LBLOCK [
          STR "(" ;
          STR ty;
          STR ",";
          va#toPretty;
          STR ",";
          size#toPretty;
	  STR ",";
          key#toPretty;
          STR ",";
          INT width; STR ")"] in
    let encs = List.filter (fun (ty, start, size, _, _) ->
      ty = "xor" && va#le start && start#lt (va#add_int len)) encodings in
    begin
      List.iter
        (fun enc -> chlog#add "use encoding" (encoding_to_pretty enc)) encs;
      encs
    end

  method decode_string s (va:doubleword_int) =
    match self#get_encodings va (String.length s) with
    | [] -> s
    | encodings -> decode_string s va encodings

  method get_file_string ?(hexSize=wordzero) (hexOffset:doubleword_int) =
    let offset = hexOffset#to_int in
    let size = hexSize#to_int in
    let len = String.length !file_as_string in    
    if size > 0 then
      if offset > len then
	let hexLen =
          fail_tvalue
            (trerror_record
               (LBLOCK [
                    STR "system_info:get_file_string:hexLen: "; INT len]))
          (int_to_doubleword len) in
	begin
	  ch_error_log#add
            "invalid argument"
	    (LBLOCK [
                 STR "Unable to return input at offset ";
                 hexOffset#toPretty;
		 STR " -- file size = ";
                 hexLen#toPretty ]);
	  raise
            (Invalid_argument
               "assembly_xreference_t#get_exe_string_at_offset")
	end
      else
	if offset + size > len then
	  let sizeAvailable = len - offset in
          if size - sizeAvailable < 10 then
	    begin
	      ch_error_log#add
                "continue operation with error"
	        (LBLOCK [
                     STR "Unable to return the requested size ";
		     STR " (";
                     INT size; STR " ); ";
		     STR "only returning ";
                     INT sizeAvailable;
                     STR " and filling up the rest with zeroes"]);
              if len > offset then
                let missing = Bytes.make (size - sizeAvailable) (Char.chr 0) in
	        String.concat
                  ""
                  [string_suffix !file_as_string offset;
                   Bytes.to_string missing]
              else
                raise (BCH_failure
                         (LBLOCK [
                              STR "get-file-string (error case): ";
                              STR "String.suffix: Length: ";
                              INT len;
                              STR "; offset: ";
                              INT offset]))
	    end
          else
            begin
              ch_error_log#add
                "continue operation with error"
                (LBLOCK [
                     STR "Unable to return the requested size ";
                     STR " (" ; INT size ; STR " ); ";
                     STR "only returning ";
                     INT sizeAvailable]);
              if len > offset then
                string_suffix !file_as_string offset
              else
                raise (BCH_failure
                         (LBLOCK [
                              STR "get-file-string (error case): ";
                              STR "String.suffix: Length: ";
                              INT len;
                              STR "; offset: ";
                              INT offset]))
            end
	else
	  String.sub !file_as_string offset size
    else
      if len > offset then
        string_suffix !file_as_string offset
      else
        raise
          (BCH_failure
             (LBLOCK [
                  STR "get-file-string: String.suffix: Length: ";
                  INT len;
                  STR "; offset: ";
                  INT offset]))
	
  method set_image_base (a:doubleword_int) = 
    begin image_base <- a ; system_data#set_image_base a end
    
  method get_image_base = image_base
    
  method set_base_of_code_rva (a:doubleword_int) = base_of_code_rva <- a
    
  method get_base_of_code_rva = base_of_code_rva

  method is_code_address = is_code_address
    
  method set_address_of_entry_point (a:doubleword_int) = 
    begin
      address_of_entry_point <- a ;
      ignore (functions_data#add_function a)
    end
  method get_address_of_entry_point = address_of_entry_point 
    
  method add_locked_instruction (a:doubleword_int) = locked_instructions#add a
    
  method is_locked_instruction (a:doubleword_int) = locked_instructions#has a
    
  method add_bound_library_function (a:doubleword_int) (name:string * string) = 
    if a#equal wordzero then () else H.add bound_library_functions a#index name
      
  method get_bound_library_function (a:doubleword_int) =
    if H.mem bound_library_functions a#index then
      H.find bound_library_functions a#index
    else
      begin
	ch_error_log#add
          "invocation error"
	  (LBLOCK [
               STR "No bound library function found for "; a#toPretty]);
	raise (Invocation_error "system_info#get_bound_library_function")
      end
	
  method has_bound_library_function (a:doubleword_int) = 
    H.mem bound_library_functions a#index

  method private write_xml_loaded_dlls (node:xml_element_int) =
    let dlls = self#get_lib_functions_loaded in
    node#appendChildren (List.map (fun (dll,functions) ->
      let dNode = xmlElement "dll" in
      begin
	dNode#appendChildren (List.map (fun fn ->
	  let fNode = xmlElement "fn" in
	  begin fNode#setAttribute "fname" fn ; fNode end) functions);
	dNode#setAttribute "name" dll ;
	dNode
      end) dlls)

  method private write_xml_thread_start_functions (node:xml_element_int) =
    let set n tag s = n#setAttribute tag s in
    let dw i = TR.tget_ok (index_to_doubleword i) in
    let seta n tag i = n#setAttribute tag (dw i)#to_hex_string in
    let fns = ref []  in
    let _ = H.iter (fun k v -> fns := (k,v) :: !fns) thread_start_functions in
    node#appendChildren (List.map (fun (sa,entry) ->
      let saNode = xmlElement "thread-start-function" in
      let instances = ref [] in
      let _ = H.iter (fun k v -> instances := (k,v) :: !instances) entry in
      begin
	saNode#appendChildren (List.map (fun ((faddr,iaddr),args) ->
	  let cNode = xmlElement "creator" in
	  begin
	    cNode#appendChildren (List.map (fun x ->
	      let eNode = xmlElement "arg" in
	      begin id#write_xml_bterm eNode x ; eNode end) args) ;
	    seta cNode "fa" faddr ;
	    set cNode "ia" iaddr ;
	    cNode
	  end) !instances) ;
	seta saNode "start-address" sa ;
	saNode
      end) !fns)

  method private write_xml_goto_returns (node:xml_element_int) =
    node#appendChildren (List.map (fun (iaddr,tgt) ->
      let iNode = xmlElement "goto" in
      let seta tag a = iNode#setAttribute tag a#to_hex_string in
      begin
        seta "ia" iaddr;
        seta "tgt" tgt;
        iNode
      end) goto_returns#listOfPairs)

  method private write_xml_call_back_tables (node: xml_element_int) =
    callbacktables#write_xml node

  method private write_xml_struct_tables (node: xml_element_int) =
    structtables#write_xml node
    
  method write_xml (node: xml_element_int) =
    let append = node#appendChildren in
    let fNode = xmlElement "functions-data" in
    let dNode = xmlElement "data-blocks" in
    let jNode = xmlElement "jump-tables" in
    let sNode = xmlElement "string-xreferences" in
    let lNode = xmlElement "loaded-dlls" in
    let tNode = xmlElement "thread-start-functions" in
    let gNode = xmlElement "goto-returns" in
    let cbNode = xmlElement "call-back-tables" in
    let stNode = xmlElement "struct-tables" in
    (* let viNode = xmlElement "variable-introductions" in *)
    begin
      functions_data#write_xml fNode;
      self#write_xml_data_blocks dNode;
      self#write_xml_jumptables jNode;
      self#write_xml_loaded_dlls lNode;
      self#write_xml_thread_start_functions tNode;
      self#write_xml_goto_returns gNode;
      self#write_xml_call_back_tables cbNode;
      self#write_xml_struct_tables stNode;
      (* self#write_xml_variable_introductions viNode; *)
      string_table#write_xml sNode;
      append [
          fNode; lNode; dNode; jNode; sNode; tNode; gNode; cbNode; stNode]
    end
      
end


let system_info = new system_info_t
